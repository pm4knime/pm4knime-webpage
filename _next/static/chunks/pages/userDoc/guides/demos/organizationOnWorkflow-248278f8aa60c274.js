(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[414],{2067:function(e,i,s){"use strict";s.r(i),s.d(i,{default:function(){return o}});var t=s(9600),n=s(7857),r=s(5893);function o(){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.Z,{}),(0,r.jsx)("div",{className:"container",children:(0,r.jsx)("div",{className:"section",children:(0,r.jsx)("div",{class:"Layout-main","data-view-component":"true",children:(0,r.jsx)("div",{id:"wiki-body",class:"gollum-markdown-content",children:(0,r.jsx)("div",{class:"markdown-body",children:(0,r.jsx)("div",{class:"Layout-main","data-view-component":"true",children:(0,r.jsx)("div",{id:"wiki-body",class:"gollum-markdown-content",children:(0,r.jsx)("div",{class:"markdown-body",children:(0,r.jsx)("div",{class:"Layout-main","data-view-component":"true",children:(0,r.jsx)("div",{id:"wiki-body",class:"gollum-markdown-content",children:(0,r.jsxs)("div",{class:"markdown-body",children:[(0,r.jsxs)("p",{children:["This part demonstrates the methods in KNIME to clean up workflow and provide better organization on workflow. One example workflow is to filter out the traces which are started before one date at first. Next, the kept traces after this time are used to discover one Petri net. To clean up the workflow, the filtering operation is wrapped as node ",(0,r.jsx)("strong",{children:"Preparation"}),"."]}),(0,r.jsx)("p",{children:(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/demo-advanced-wrap-02.PNG",alt:"",width:"500px",height:"200px",className:"img-fluid img-shadow"})}),(0,r.jsxs)("p",{children:["The workflow before the wrapping is shown in the following figure. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/demo-advanced-wrap-wf-02.PNG",alt:"image",className:"img-fluid img-shadow"})," ",(0,r.jsx)("br",{})," There are two ways to wrap the nodes, one way is to create MetaNode, another way is to create Component. The difference can be found in this ",(0,r.jsx)("a",{href:"https://docs.knime.com/2019-06/analytics_platform_metanode_guide/index.html",rel:"nofollow",children:"link"}),". Below, both methods are shown. The MetaNode is shown as first. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/MetaNode-design-01.PNG",alt:"image",className:"img-fluid img-shadow"})," ",(0,r.jsx)("br",{})," After opening the MetaNode, it looks like ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/MetaNode-open-01.PNG",alt:"image",className:"img-fluid img-shadow"})," Organized in Component. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/Component-design-01.PNG",alt:"image",className:"img-fluid img-shadow"})," ",(0,r.jsx)("br",{}),"After opening the MetaNode, it looks like ",(0,r.jsx)("br",{})," ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/Component-open-02.PNG",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsx)("p",{children:"The following steps show how to wrap the workflow."}),(0,r.jsx)("ol",{children:(0,r.jsx)("li",{children:"Create the workflow with all nodes expanded."})}),(0,r.jsxs)("ul",{children:[(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Download the dataset ",(0,r.jsx)("code",{children:"chapter_1 "}),"from the ",(0,r.jsx)("a",{href:"https://github.com/pm4knime/pm4knime-document/blob/master/dataset/chapter_1.zip",children:"github link"})," and extract it to get the event log ",(0,r.jsx)("code",{children:"running-example.csv"}),"."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Import ",(0,r.jsx)("code",{children:"running-example.csv"})," with node ",(0,r.jsx)("strong",{children:"CSV Reader"}),"."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Define a Flow Variable ",(0,r.jsx)("code",{children:"startDateVar"})," in String with node ",(0,r.jsx)("strong",{children:"String Input"}),". This Flow Variable ",(0,r.jsx)("code",{children:"startDateVar"})," defines the filtering criteria. After this date, all the events are filtered out.",(0,r.jsx)("br",{})," ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/StringInput-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"})]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Filter the events rows out if its timestamp is before the defined ",(0,r.jsx)("code",{children:"startDateVar"}),"."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Drag node ",(0,r.jsx)("strong",{children:"Rule-based Row Splitter"})," into KNIME. This node outputs two Data Tables, one contains rows matching the rule, the other rows are contained in the second Data Table. More information can also be found in the ",(0,r.jsx)("a",{href:"https://www.knime.com/knime-introductory-course/chapter3/section4/data-manipulation-numbers-strings-rules",rel:"nofollow",children:"vidoe"}),"."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Connect the node ",(0,r.jsx)("strong",{children:"Rule-based Row Splitter"})," with the output port of ",(0,r.jsx)("strong",{children:"String Input"})," and of ",(0,r.jsx)("strong",{children:"CSV Reader"}),"."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("p",{children:["Configure ",(0,r.jsx)("strong",{children:"Rule-based Row Splitter"})," with the following condition."]})})]}),(0,r.jsx)("blockquote",{children:(0,r.jsxs)("p",{children:["$#Event Attribute#time:timestamp$ >= $$","{SstartDateVar}","$$ => TRUE"]})}),(0,r.jsx)("p",{children:(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/RuleSplitter-configruation-01.PNG",alt:"image",className:"img-fluid img-shadow"})}),(0,r.jsx)("ul",{children:(0,r.jsxs)("li",{children:["After execution, two tables are output as shown in the following. ",(0,r.jsx)("img",{title:"First Data Table with matching rows",src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/RuleSplitter-result-01.PNG",alt:"image",className:"img-fluid img-shadow"})]})}),(0,r.jsx)("p",{children:(0,r.jsx)("img",{title:"Second Data table without matching rows",src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/RuleSplitter-configruation-02.PNG",alt:"image",className:"img-fluid img-shadow"})}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Extract the caseIDs from the second Data Table which start before the ",(0,r.jsx)("code",{children:"startDateVar"})," by node ",(0,r.jsx)("strong",{children:"GrouBy"}),". ",(0,r.jsx)("img",{title:"Configuration on GroupBy",src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/GroupBy-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"})," ",(0,r.jsx)("img",{title:"Resutl after execution on GroupBy",src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/GroupBy-result-01.PNG",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("li",{children:["Filter out the rows with the caseIDs from the result of ",(0,r.jsx)("strong",{children:"GroupBy"}),"."]}),(0,r.jsxs)("li",{children:["Import the node ",(0,r.jsx)("strong",{children:"Reference Row Filter"}),". The configuration is like ",(0,r.jsx)("img",{title:"Reference Row Filter Configuration",src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/ReferenceRowFilter-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("li",{children:["Execute ",(0,r.jsx)("strong",{children:"Reference Row Filter"})," and get the result ",(0,r.jsx)("img",{title:"Reference Row Filter Result",src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/ReferenceRowFilter-result-01.PNG",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsx)("li",{children:"Convert CSV into an event log"}),(0,r.jsxs)("li",{children:["Discover a Petri net with node ",(0,r.jsx)("strong",{children:"Inductive Miner"}),". The settings are"]})]}),(0,r.jsx)("blockquote",{children:(0,r.jsx)("p",{children:"Strategy: Inductive Miner -Infrequent Noise Threshold: 0.2"})}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Replay the event log on the Petri net with node ",(0,r.jsx)("strong",{children:"Alignment-Based Replayer(Default)"}),"."]}),(0,r.jsxs)("li",{children:["Check the fitness with node ",(0,r.jsx)("strong",{children:"Fitness Checker"}),"."]})]}),(0,r.jsx)("ol",{start:"2",children:(0,r.jsxs)("li",{children:["Wrap the nodes from ",(0,r.jsx)("strong",{children:"CSV Reader"})," to ",(0,r.jsx)("strong",{children:"Inductive Miner"})," as the node ",(0,r.jsx)("code",{children:"Preparation"}),"."]})}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Select the related nodes, right click and choose ",(0,r.jsx)("code",{children:"Create Metanode"})," ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/MetaNode-design-mata.png",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("li",{children:["After this, it generates the result like this, Its configuration contains no option. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/MetaNode-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"})]})]}),(0,r.jsxs)("p",{children:["However, in the ",(0,r.jsx)("strong",{children:"MetaNode"}),", the ",(0,r.jsx)("code",{children:"startDataVar"})," can't be modified to allow flexible settings. To allow the ",(0,r.jsx)("code",{children:"MetaNode"})," configurable, we use another method ",(0,r.jsx)("strong",{children:"Component"}),"."]}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Select the related nodes, right click and choose ",(0,r.jsx)("code",{children:"Create Component"})," ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/Component-design-component.png",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("li",{children:["After this, it generates the result like this, Its configuration contains option like defined in node ",(0,r.jsx)("strong",{children:"String Input"}),". ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/Component-configuration-withStr.PNG",alt:"image",className:"img-fluid img-shadow"})]})]}),(0,r.jsx)("p",{children:"This section is more applicable on complex workflow"})]})})})})})})})})})})}),(0,r.jsx)(n.Z,{})]})}},7857:function(e,i,s){"use strict";var t=s(5893);i.Z=function(e){return(0,t.jsx)("footer",{className:"footer",children:(0,t.jsxs)("div",{className:"container",style:{display:"flex",justifyContent:"space-between"},children:[(0,t.jsxs)("span",{className:"text-muted float-left",children:["PM4KNIME is a product of the ",(0,t.jsx)("a",{href:"https://fit.fraunhofer.de",target:"_blank",children:"Fraunhofer Institute for Applied Information Technology (FIT)"})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)("a",{className:"float-right",href:"#","data-toggle":"modal","data-target":"#DataProtectionModal",children:"Data Protection"}),(0,t.jsx)("span",{className:"float-right ml-1 mr-1 text-muted",children:"|"}),(0,t.jsx)("a",{className:"float-right",href:"#","data-toggle":"modal","data-target":"#ImprintModal",children:"Imprint"})]})]})})}},9600:function(e,i,s){"use strict";s(7294);var t=s(4593),n=s(1664),r=s.n(n),o=s(634),a=s(682),l=s(9368),c=s(3210),d=s(5893),m=function(){return(0,d.jsxs)(t.q,{children:[(0,d.jsx)("meta",{charSet:"UTF-8"}),(0,d.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1"}),(0,d.jsx)("title",{children:"PM4KNIME"}),(0,d.jsx)("link",{rel:"apple-touch-icon",sizes:"180x180",href:"/assets/pm4knimeLogo.png"}),(0,d.jsx)("link",{rel:"icon",type:"image/png",sizes:"32x32",href:"/assets/pm4knimeLogo.png"}),(0,d.jsx)("link",{rel:"icon",type:"image/png",sizes:"16x16",href:"/assets/pm4knimeLogo.png"}),(0,d.jsx)("meta",{name:"description",content:"PM4KNIME implements state-of-the-art process mining algorithms."}),(0,d.jsx)("meta",{name:"google",content:"notranslate"})]})},h=function(){return(0,d.jsx)(d.Fragment,{children:(0,d.jsx)(o.Z,{className:"mx-auto color-nav",collapseOnSelect:!0,expand:"lg",variant:"light",fixed:"top",children:(0,d.jsxs)(a.Z,{children:[(0,d.jsxs)(o.Z.Brand,{children:[(0,d.jsx)("a",{className:"navbar-brand",href:"https://fit.fraunhofer.de",children:(0,d.jsx)("img",{src:"/assets/fit_logo.svg",width:"auto",height:"30",className:"d-inline-block align-top",alt:""})}),(0,d.jsx)(r(),{href:"/",children:(0,d.jsxs)("a",{className:"navbar-brand pl-4 pr-4",style:{paddingLeft:"15px"},children:[(0,d.jsx)("img",{src:"assets/pm4knimeLogo.png",width:"auto",height:"30",className:"d-inline-block align-top",alt:""}),"PM4KNIME"]})})]}),(0,d.jsx)(o.Z.Toggle,{"aria-controls":"responsive-navbar-nav"}),(0,d.jsxs)(o.Z.Collapse,{id:"responsive-navbar-nav",children:[(0,d.jsx)(l.Z,{className:"ms-auto",children:(0,d.jsx)(r(),{href:"/userDoc/",passHref:!0,children:(0,d.jsx)(l.Z.Link,{children:"Home"})})}),(0,d.jsx)(l.Z,{children:(0,d.jsxs)(c.Z,{title:"Guideline for normal user",id:"collasible-nav-dropdown",children:[(0,d.jsx)(r(),{href:"/userDoc/guides/",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Introduction Guides"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/features",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"PM4KNIME Features"})}),(0,d.jsx)(c.Z.Divider,{}),(0,d.jsx)(r(),{href:"/userDoc/guides/installation",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Installation Instructions"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/importantConcepts",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"KNIME Important Concepts"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/bugReport",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Bug Report"})}),(0,d.jsx)(c.Z.Divider,{}),(0,d.jsx)(r(),{href:"/userDoc/guides/knimeServer",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"KNIME Server Usage"})})]})}),(0,d.jsx)(l.Z,{children:(0,d.jsxs)(c.Z,{title:"Usage Examples",id:"collasible-nav-dropdown",children:[(0,d.jsx)(r(),{href:"/userDoc/guides/demos",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Introduction Demos"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/processDiscovery",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Process Discovery"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/conformance",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Confromance"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/logManipulation",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Log Manipulation"})}),(0,d.jsx)(c.Z.Divider,{}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/repetiveExecution",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Repetitive Execution of Workflow"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/parameterOptimization",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Parameter Optimization"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/organizationOnWorkflow",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Organization on Workflow"})}),(0,d.jsx)(c.Z.Divider,{}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/knimeNodes",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"KNIME Nodes"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/workWithJava",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Working with Java"})}),(0,d.jsx)(r(),{href:"/userDoc/guides/demos/workWithPython",passHref:!0,children:(0,d.jsx)(c.Z.Item,{children:"Working with Python"})})]})})]})]})})})};i.Z=function(e){return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(m,{}),(0,d.jsx)(h,{})]})}},9:function(e,i,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/userDoc/guides/demos/organizationOnWorkflow",function(){return s(2067)}])}},function(e){e.O(0,[929,774,888,179],(function(){return i=9,e(e.s=i);var i}));var i=e.O();_N_E=i}]);