(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[13],{6977:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return n}});var s=i(9600),o=i(7857),r=i(5893);function n(){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.Z,{}),(0,r.jsx)("div",{className:"container",children:(0,r.jsx)("div",{className:"section",children:(0,r.jsx)("div",{class:"Layout-main","data-view-component":"true",children:(0,r.jsx)("div",{id:"wiki-body",class:"gollum-markdown-content",children:(0,r.jsx)("div",{class:"markdown-body",children:(0,r.jsx)("div",{class:"Layout-main","data-view-component":"true",children:(0,r.jsx)("div",{id:"wiki-body",class:"gollum-markdown-content",children:(0,r.jsx)("div",{class:"markdown-body",children:(0,r.jsx)("div",{class:"Layout-main","data-view-component":"true",children:(0,r.jsx)("div",{id:"wiki-body",class:"gollum-markdown-content",children:(0,r.jsxs)("div",{class:"markdown-body",children:[(0,r.jsxs)("p",{children:["In this part, the demand to do experiment with different parameters settings is shown at first. Next, the concrete workflow is provided as one sample to solve a similar problem. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/demo-advanced-loop.PNG",alt:"",width:"600px",height:"150px",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("p",{children:["In [https://www.knime.com/nodeguide/control-structures/loops/example-for-recursive-replacement-of-strings] describes the use of loop to recursively execute the workflow. ",(0,r.jsx)("em",{children:(0,r.jsx)("strong",{children:"Recursive Loop Start/End"})})," is used to build the structure. For Recursive Loop End, there are at least 2 out ports, port 0 to output the data, other output ports data will be passed again into the loop."]}),(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Attention!!!"})}),(0,r.jsxs)("p",{children:["There are hidden flow variables in Node ",(0,r.jsx)("em",{children:(0,r.jsx)("strong",{children:"XX_Loop_Start/End"})}),". They are local flow variables and defined by the node. We can connect the other nodes to use the flow variables. Even output them into the data table."]}),(0,r.jsxs)("p",{children:["One sample from KNIME is given ",(0,r.jsx)("br",{}),(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/demo-advanced-loop-wf.PNG",alt:"",width:"800px",height:"400px",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("p",{children:["The goal of this workflow is to discover different process models in Petri net with different noise thresholds under the strategy ",(0,r.jsx)("code",{children:"Inductive Miner -- Infrequent"}),". Steps to create the workflow above are"]}),(0,r.jsxs)("ol",{children:[(0,r.jsxs)("li",{children:["Download the event log ",(0,r.jsx)("code",{children:"repairExample.xes"})," and the parameter settings excel file 'demo-loop-discovery-noise-threshold.xlsx' from the ",(0,r.jsx)("a",{href:"https://github.com/pm4knime/pm4knime-document/blob/master/dataset/chapter_8.zip",children:"dataset"}),". 'demo-loop-discovery-noise-threshold.xlsx' saves the different noise threshold for Inductive Miner."]}),(0,r.jsx)("li",{children:"Import the event log file and the parameter settings file."})]}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Import the event log with node ",(0,r.jsx)("strong",{children:"Event Log Reader"}),"."]}),(0,r.jsxs)("li",{children:["Import the Parameter settings file with node ",(0,r.jsx)("strong",{children:"Excel Reader(XLS)"}),". The configuration looks in the following way. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/XLSReader-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"})]})]}),(0,r.jsx)("p",{children:"The noise-threshold can be seen through Preview Tab at the bottom, which helps read the parameter settings right."}),(0,r.jsx)("ol",{start:"3",children:(0,r.jsxs)("li",{children:["Begin Loop with predefined ",(0,r.jsx)("code",{children:"Loop Structure"})," in KNIME. ",(0,r.jsx)("code",{children:"Loop Structure"})," requires the explicit ",(0,r.jsx)("strong",{children:"XX Loop Start"})," and ",(0,r.jsx)("strong",{children:"XX Loop End"})," nodes. The workflow between ",(0,r.jsx)("strong",{children:"XX Loop Start"})," and ",(0,r.jsx)("strong",{children:"XX Loop End"})," is the loop body and executed with the specified iterations. There are multiple nodes in KNIME. More information can be found with this ",(0,r.jsx)("a",{href:"https://www.knime.com/nodeguide/control-structures/loops",rel:"nofollow",children:"link"}),"."]})}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["In the current case, use the node ",(0,r.jsx)("strong",{children:"Table Row to Variable Loop Start"}),", which reads from the Data Table and generates the Flow Variable according to the column specification. In every loop, it reads the next row assigns the values to Flow Variables."]}),(0,r.jsxs)("li",{children:["Drag ",(0,r.jsx)("strong",{children:"Inductive Miner"})," into KNIME for the process discovery. As known, the discovery is repeated with different noise threshold settings. Therefore, it should be put into the right side of the loop node ",(0,r.jsx)("strong",{children:"Table Row to Variable Loop Start"}),"."]}),(0,r.jsxs)("li",{children:["Configure the node ",(0,r.jsx)("strong",{children:"Inductive Miner"}),".",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Set the Inductive Miner strategy to be ",(0,r.jsx)("code",{children:"Inductive Miner -- Infrequent"})]}),(0,r.jsxs)("li",{children:['Set the noise threshold by going the Tab FlowVariable and clicking the DropDown Box at NoiseThreshold. Choose the flow variable "noise-threshold". ',(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/InductiveMiner-configuration-fv-01.PNG",alt:"image"})," After this, the configuration panel looks like this ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/InductiveMiner-configuration-fv-02.PNG",alt:"image",className:"img-fluid img-shadow"})]})]})]}),(0,r.jsxs)("li",{children:["Export the Petri net with the node ",(0,r.jsx)("strong",{children:"Petrinet Writer"}),". To avoid the overwriting error happening with the same name for exporting Petri net. Different names should be given according to the noise threshold."]}),(0,r.jsxs)("li",{children:["Drag ",(0,r.jsx)("strong",{children:"Create File Name"})," into KNIME to generate the file name for exporting the Petri net.",(0,r.jsx)("br",{})," * Connect with the output port ",(0,r.jsx)("code",{children:"Flow Variable"})," in Node ",(0,r.jsx)("strong",{children:"Table Row to Variable Loop Start"})," to get the ",(0,r.jsx)("code",{children:"noise threshold"})," value. * Configure the node with the following settings.",(0,r.jsx)("br",{})," ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/FileName-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"}),(0,r.jsx)("br",{})," It generates the one ",(0,r.jsx)("code",{children:"Flow Variable"})," called ",(0,r.jsx)("code",{children:"filePath"}),". ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/FileName-result-01.PNG",alt:"image",className:"img-fluid img-shadow"})]}),(0,r.jsxs)("li",{children:["Connect the output port ",(0,r.jsx)("code",{children:"Flow Variable"})," in Node ",(0,r.jsx)("strong",{children:"Create File Name"})," to assign ",(0,r.jsx)("code",{children:"filePath"})," to the Petri net file path"]})]}),(0,r.jsx)("ol",{start:"4",children:(0,r.jsxs)("li",{children:["End Loop with node ",(0,r.jsx)("strong",{children:"Variable Loop End"}),". This node requires the input type is ",(0,r.jsx)("code",{children:"Flow Variable"}),". To output the filePath and noise threshold, we connect the output port of ",(0,r.jsx)("strong",{children:"Create File Name"})," with the input port of ",(0,r.jsx)("strong",{children:"Variable Loop End"}),"."]})}),(0,r.jsx)("ul",{children:(0,r.jsxs)("li",{children:["Configure the ",(0,r.jsx)("strong",{children:"Variable Loop End"})," to specify its output data. Flow Variable ",(0,r.jsx)("code",{children:"filePath"}),", ",(0,r.jsx)("code",{children:"noise-threshold"})," and ",(0,r.jsx)("code",{children:"RowID"})," are chosen. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/LoopEnd-Variable-configuration-01.PNG",alt:"image",className:"img-fluid img-shadow"})]})}),(0,r.jsx)("ol",{start:"5",children:(0,r.jsxs)("li",{children:["Execute the loop simply by clicking the last node ",(0,r.jsx)("strong",{children:"Variable Loop End"}),". Or click the Running button at the top menu. After execution, all the outputs from each loop is summarized at the output port of ",(0,r.jsx)("strong",{children:"Variable Loop End"}),". The following figure shows one overview. ",(0,r.jsx)("img",{src:"https://github.com/pm4knime/pm4knime-document/raw/master/images/LoopEnd-Variable-result-01.PNG",alt:"image",className:"img-fluid img-shadow"})]})})]})})})})})})})})})})}),(0,r.jsx)(o.Z,{})]})}},7857:function(e,t,i){"use strict";var s=i(5893);t.Z=function(e){return(0,s.jsx)("footer",{className:"footer",children:(0,s.jsxs)("div",{className:"container",style:{display:"flex",justifyContent:"space-between"},children:[(0,s.jsxs)("span",{className:"text-muted float-left",children:["PM4KNIME is a product of the ",(0,s.jsx)("a",{href:"https://fit.fraunhofer.de",target:"_blank",children:"Fraunhofer Institute for Applied Information Technology (FIT)"})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("a",{className:"float-right",href:"#","data-toggle":"modal","data-target":"#DataProtectionModal",children:"Data Protection"}),(0,s.jsx)("span",{className:"float-right ml-1 mr-1 text-muted",children:"|"}),(0,s.jsx)("a",{className:"float-right",href:"#","data-toggle":"modal","data-target":"#ImprintModal",children:"Imprint"})]})]})})}},9600:function(e,t,i){"use strict";i(7294);var s=i(4593),o=(i(1664),i(634)),r=i(682),n=i(9368),a=i(3210),l=i(5893),d=function(){return(0,l.jsxs)(s.q,{children:[(0,l.jsx)("meta",{charSet:"UTF-8"}),(0,l.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1"}),(0,l.jsx)("title",{children:"PM4KNIME"}),(0,l.jsx)("link",{rel:"apple-touch-icon",sizes:"180x180",href:"/assets/pm4knimeLogo.png"}),(0,l.jsx)("link",{rel:"icon",type:"image/png",sizes:"32x32",href:"/assets/pm4knimeLogo.png"}),(0,l.jsx)("link",{rel:"icon",type:"image/png",sizes:"16x16",href:"/assets/pm4knimeLogo.png"}),(0,l.jsx)("meta",{name:"description",content:"PM4KNIME implements state-of-the-art process mining algorithms."}),(0,l.jsx)("meta",{name:"google",content:"notranslate"})]})},h=function(){return(0,l.jsx)(l.Fragment,{children:(0,l.jsx)(o.Z,{className:"mx-auto color-nav",collapseOnSelect:!0,expand:"lg",variant:"light",fixed:"top",children:(0,l.jsxs)(r.Z,{children:[(0,l.jsxs)(o.Z.Brand,{children:[(0,l.jsx)("a",{className:"navbar-brand",href:"https://fit.fraunhofer.de",children:(0,l.jsx)("img",{src:"/assets/fit_logo.svg",width:"auto",height:"30",className:"d-inline-block align-top",alt:""})}),(0,l.jsxs)("a",{className:"navbar-brand pl-4 pr-4",style:{paddingLeft:"15px"},href:"/",children:[(0,l.jsx)("img",{src:"/assets/pm4knimeLogo.png",width:"auto",height:"30",className:"d-inline-block align-top",alt:""}),"PM4KNIME"]})]}),(0,l.jsx)(o.Z.Toggle,{"aria-controls":"responsive-navbar-nav"}),(0,l.jsxs)(o.Z.Collapse,{id:"responsive-navbar-nav",children:[(0,l.jsx)(n.Z,{className:"ms-auto",children:(0,l.jsx)(n.Z.Link,{href:"userDoc",children:"Home"})}),(0,l.jsx)(n.Z,{children:(0,l.jsxs)(a.Z,{title:"Guideline for normal user",id:"collasible-nav-dropdown",children:[(0,l.jsx)(a.Z.Item,{href:"userDoc/guides",children:"Introduction Guides"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/features",children:"PM4KNIME Features"}),(0,l.jsx)(a.Z.Divider,{}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/installation",children:"Installation Instructions"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/importantConcepts",children:"KNIME Important Concepts"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/bugReport",children:"Bug Report"}),(0,l.jsx)(a.Z.Divider,{}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/knimeServer",children:"KNIME Server Usage"})]})}),(0,l.jsx)(n.Z,{children:(0,l.jsxs)(a.Z,{title:"Usage Examples",id:"collasible-nav-dropdown",children:[(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/",children:"Introduction Demos"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/processDiscovery",children:"Process Discovery"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/conformance",children:"Confromance"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/logManipulation",children:"Log Manipulation"}),(0,l.jsx)(a.Z.Divider,{}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/repetiveExecution",children:"Repetitive Execution of Workflow"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/parameterOptimization",children:"Parameter Optimization"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/organizationOnWorkflow",children:"Organization on Workflow"}),(0,l.jsx)(a.Z.Divider,{}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/knimeNodes",children:"KNIME Nodes"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/workWithJava",children:"Working with Java"}),(0,l.jsx)(a.Z.Item,{href:"userDoc/guides/demos/workWithPython",children:"Working with Python"})]})})]})]})})})};t.Z=function(e){return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(d,{}),(0,l.jsx)(h,{})]})}},7909:function(e,t,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/userDoc/guides/demos/repetiveExecution",function(){return i(6977)}])}},function(e){e.O(0,[929,774,888,179],(function(){return t=7909,e(e.s=t);var t}));var t=e.O();_N_E=t}]);